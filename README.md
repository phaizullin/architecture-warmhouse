# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удалённо включать/выключать отопление в своих домах.
- Система поддерживает специальные датчики и реле.
- Самостоятельно подключить свой датчик к системе пользователь не может.

**Мониторинг температуры:**

- Система синхронно получает данные о температуре с датчиков, установленных в домах. 
- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.

### 2. Анализ архитектуры монолитного приложения

- Язык программирования: Go
- База данных: PostgreSQL
- Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
- Взаимодействие: Синхронное, запросы обрабатываются последовательно.
- Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
- Развертывание: Требует остановки всего приложения.

### 3. Определение доменов и границы контекстов

**As-Is**

**Домен: Управление устройствами**
- **Поддомен: Управление отоплением**
  - Контекст: Команды включения/выключения отопления
  - Контекст: Установка и настройка устройств отопления (выполняется специалистом)

- **Поддомен: Мониторинг температуры**
  - Контекст: Сбор данных о температуре (синхронно)
  - Контекст: Отображение данных о текущей температуре

**To-Be**

**Домен: Управление устройствами**
- **Поддомен: Управление отоплением**
  - Контекст: Команды управления системами отопления
  - Контекст: Мониторинг состояния отопительных приборов

- **Поддомен: Управление освещением**
  - Контекст: Команды включения/выключения света
  - Контекст: Настройка режимов освещения

- **Поддомен: Управление безопасностью**
  - Контекст: Управление автоматическими воротами
  - Контекст: Видеонаблюдение

- **Поддомен: Интеграция сторонних устройств**
  - Контекст: Поддержка стандартных протоколов
  - Контекст: Адаптация новых типов устройств

**Домен: Управление пользователями**
- **Поддомен: Учетные записи**
  - Контекст: Регистрация и аутентификация
  - Контекст: Управление профилями и доступами

- **Поддомен: Самообслуживание**
  - Контекст: Самостоятельное подключение устройств
  - Контекст: Настройка пользовательских сценариев

**Домен: Телеметрия и аналитика**
- **Поддомен: Сбор и хранение данных**
  - Контекст: Получение данных от устройств (асинхронно)
  - Контекст: Долгосрочное хранение исторических данных

- **Поддомен: Аналитика и отчетность**
  - Контекст: Визуализация данных для пользователей
  - Контекст: Анализ работы устройств и систем

**Домен: Продажи и подписки**
- **Поддомен: Управление подписками**
  - Контекст: Модель SaaS и тарификация
  - Контекст: Биллинг и платежи

- **Поддомен: Продажа комплектов устройств**
  - Контекст: Каталог доступных устройств и комплектов
  - Контекст: Интеграция с партнерами-производителями

### **4. Проблемы монолитного решения**

- Ограниченная масштабируемость под нагрузки
- Сложность независимого развертывания фунционала, обновление требует полной сборки
- Изменения в одном функционале могут повлиять на другие. Проблема отказоустойчивости
- Длительные и зачастуе кросскомандные циклы разработки. CI/CD прогоняется на весь функционал
- Синхронные вызовы к датчикам и реле, что вызыввет ожидания в ответах от устройств (но тут проблема не совсем в монолите)
- Как правило единая БД, которую также сложно масштабировать под нагрузки
- Есть борьба под серверные ресурсы, так как полностью выделяются под монолит. Может страдать производительность
- Единый стек на весь монолит, смена технологий ограничена

### 5. Визуализация контекста системы — диаграмма С4

[Диаграмма контекста системы "Теплый дом" - As-Is](diagrams/As-Is/context.png)

Исходный код диаграммы находится в файле [diagrams/As-Is/context.puml](diagrams/As-Is/context.puml)

# Задание 2. Проектирование микросервисной архитектуры

В этом задании вам нужно предоставить только диаграммы в модели C4. Мы не просим вас отдельно описывать получившиеся микросервисы и то, как вы определили взаимодействия между компонентами To-Be системы. Если вы правильно подготовите диаграммы C4, они и так это покажут.

**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров системы "Умный дом" - To-Be](diagrams/To-Be/containers.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/containers.puml](diagrams/To-Be/containers.puml)

**Диаграмма компонентов (Components)**

[Диаграмма компонентов микросервиса "Сервис отопления"](diagrams/To-Be/components_heating_service.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/components_heating_service.puml](diagrams/To-Be/components_heating_service.puml)

[Диаграмма компонентов микросервиса "Сервис телеметрии"](diagrams/To-Be/components_telemetry_service.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/components_telemetry_service.puml](diagrams/To-Be/components_telemetry_service.puml)

[Диаграмма компонентов микросервиса "Сервис пользователей"](diagrams/To-Be/components_user_service.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/components_user_service.puml](diagrams/To-Be/components_user_service.puml)

**Диаграмма кода (Code)**

[Диаграмма кода микросервиса "Сервис отопления"](diagrams/To-Be/code_heating_service.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/code_heating_service.puml](diagrams/To-Be/code_heating_service.puml)

# Задание 3. Разработка ER-диаграммы

[ER - Диаграмма](diagrams/To-Be/er_diagram.png)

Исходный код диаграммы находится в файле [diagrams/To-Be/er_diagram.puml](diagrams/To-Be/er_diagram.puml)

# Задание 4. Создание и документирование API

### 1. Тип API

Для взаимодействия микросервисов в системе "Умный дом" используется комбинация следующих типов API:

1. **gRPC** для синхронного взаимодействия между микросервисами:
   - Высокая производительность благодаря Protocol Buffers и HTTP/2
   - Строгая типизация и автоматическая генерация клиентского/серверного кода
   - Двунаправленный потоковый обмен данными
   - Эффективно для внутренних коммуникаций между сервисами

2. **REST API** для взаимодействия с внешними клиентами и некоторыми микросервисами:
   - Простота использования и широкая поддержка
   - Подходит для публичного API (фронтенд, мобильные приложения)
   - Хорошо документируется через OpenAPI/Swagger

3. **Асинхронный обмен сообщениями через Kafka** для событийно-ориентированного взаимодействия:
   - Отличная масштабируемость и надежность доставки сообщений

4. **MQTT** для взаимодействия с устройствами умного дома:
   - Легковесный протокол для IoT устройств
   - Хорошо работает при нестабильном соединении
   - Поддержка модели публикации/подписки

### 2. Документация API

#### 2.1 Ключевые эндпоинты API

В системе "Умный дом" добавлены описания на следующие ключевые эндпоинты:

1. **Получение текущей температуры (REST API)**
   - `GET /temperature/current/{location}` - Получение текущей температуры в конкретном помещении

2. **Управление устройством отопления (REST API)**
   - `POST /devices/{deviceId}/control` - Управление устройством отопления (включение, выключение, установка температуры)

3. **Аутентификация пользователя (REST API)**
   - `POST /auth/login` - Аутентификация пользователя в системе

4. **Отправка данных о температуре (Асинхронный API)**
   - Канал `telemetry.temperature` - Асинхронное отправление данных о температуре от устройств

5. **Проверка прав доступа (gRPC)**
   - Метод `CheckPermission` - Проверка наличия у пользователя прав на выполнение определенного действия

#### 2.2 Полная документация API

Документация API для микросервисов системы "Умный дом" расположена в директории [apps/api-docs](apps/api-docs):

**REST API (OpenAPI 3.0):**
- [Сервис отопления](apps/api-docs/heating-service-openapi.yaml) - API для управления отоплением
- [Сервис телеметрии](apps/api-docs/telemetry-service-openapi.yaml) - API для работы с телеметрией
- [Сервис пользователей](apps/api-docs/user-service-openapi.yaml) - API для управления пользователями

**Асинхронный API (AsyncAPI 2.5.0):**
- [Система событий](apps/api-docs/event-driven-asyncapi.yaml) - Спецификация событийного API через Kafka

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации ./smart_home/init.sql

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


